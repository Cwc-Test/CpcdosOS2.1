/*	
	=============================================
	==   CPinti ---> Gestionnaire de threads   ==
	=============================================

	Developpe entierement par Sebastien FAVIER

	Description
		Module permettant la commutation des threads en se basant sur le PIT

	Creation
		17/05/2018
		
		
	Mise a jour
		22/05/2018
		
		

*/



#include <conio.h>
#include <ctime>
#include <dos.h>
#include <sys/time.h>
#include <cstdio>
#include <cstdlib>

#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>

#include <dpmi.h>
 
#include "core.h"

#define INIT_SCHED() ({char var; top_stack = &var;})

#define NPROC_MAX 6
#define BEGIN_PROC 2
#define INIT_PROC 0
#define SCHED_PROC 1

#define SRUN 1
#define SVOID 0

char* top_stack;

int elu = BEGIN_PROC;

struct Tproc{
  char state;
  jmp_buf buf;
  char stack[64536];
  int stack_size;
} proc[NPROC_MAX];

namespace NP_cpinti_mt
{ 
	
	


	int mysetjmp(int idx){
	  char tmp;
	  char* bottom = &tmp;
	  proc[idx].stack_size = top_stack - bottom;

	  memcpy(proc[idx].stack, 
		 bottom,
		 proc[idx].stack_size);
		
	  if(sigsetjmp(proc[idx].buf, 1)==0){ 
		return 0;
	  }
	  else{
		memcpy(top_stack - proc[elu].stack_size,
		   proc[elu].stack,
		   proc[elu].stack_size);
		return 1;
	  }
	}


	void mylongjmp(int idx){
		
		FILE * fichier;
	
		fichier = fopen("fb_debug.txt", "a");
		fprintf(fichier, "PID : %d\n", idx);
		fclose(fichier);
	
		elu = idx;
		siglongjmp(proc[idx].buf, 1);
	}

	void f(int arg){
	  int n = 0;
	  while(n<6){
		char* texte = (char*) malloc(64);
		printf("Execute processus num %d : n = %d \n",arg,n++);
		sprintf(texte, "Execute processus num %d : n = %d \n",arg,n++);
		printf_fb(texte);
		free(texte);
		
		// sleep(1);
		__dpmi_yield();
	  }
	  return;
	}


	void g(int arg){
	  int n = 0;
	  while(n<10){
		  
		  printf("Execute processus num %d : n = %d \n",arg,n++);
		char* texte = (char*) malloc(64);
	
		sprintf(texte, "Execute processus num %d : n = %d \n",arg,n++);
		printf_fb(texte);
		free(texte);
		// sleep(1);
		__dpmi_yield();
	  }
	  return;
	}



	void new_proc(void( *fun)(int), int arg){

	  sigset_t sig_proc;
	  int i;

	  for(i=BEGIN_PROC;i<NPROC_MAX && proc[i].state != SVOID; i++);
	  
	  if(i<NPROC_MAX){
		proc[i].state = SRUN;
		if(mysetjmp(i)==0){
		  return;
		}
		else{
		  fun(arg);

		  sigemptyset(&sig_proc);
		  sigaddset (&sig_proc, SIGALRM);
		  sigprocmask(SIG_BLOCK,&sig_proc, NULL);

			char* texte = (char*) malloc(64);
			printf("--------------------\n\n Tâche numéro %d terminé \n\n ---------------",arg);
			
			sprintf(texte, "--------------------\n\n Tâche numéro %d terminé \n\n ---------------",arg);
			printf_fb(texte);
			free(texte);
		
		  proc[i].state = SVOID;
		  
		  mylongjmp(SCHED_PROC);

		}
	  }

	  sigprocmask(SIG_UNBLOCK,&sig_proc, NULL);

	}



	int election(){

	  int cpt = 0;
	  int i = elu + 1;

	  if(i>=NPROC_MAX){
		i=BEGIN_PROC;
	  }

	  while(i<=NPROC_MAX){
		if(proc[i].state == SRUN){
		  return i;
		}
		else{
		  i++;
		  if(i>=NPROC_MAX){
		i = BEGIN_PROC;
		  }
		  cpt++;
		  if(cpt == NPROC_MAX ){
		// Cas où l'on a plus de processus
		siglongjmp(proc[INIT_PROC].buf,1);
		  }
		}
	  }
	}

	
	
	void commut(int no){
	  
	  
		// if(Est_Interruption() == true)
		// {
			// char* texte = (char*) malloc(64);
			// printf("\n Est dans un interrupt ON FAIT RIEN\n");  
			// sprintf(texte, "\n - - - - - - ON EST dans une interrupt ON FAIT RIEN\n");
			// printf_fb(texte);
			// free(texte);
			// return;
		// }
		
		int p = election();  

		printf("\n Commutation :  election %d | courant %d \n\n",p,elu);

		char* texte = (char*) malloc(64);
		sprintf(texte, "\n Commutation :  election %d | courant %d \n\n",p,elu);
		printf_fb(texte);
		free(texte);

	  
	  // signal(SIGALRM,&commut);
	  // alarm(1);
	  
	  if(mysetjmp(elu) == 0) {                                                                                                                         
		mylongjmp(p);
	  }
	  else{
		return;
	  }
	  
	}                                                                                                                                                                   



	void start_sched(){
	  
	  INIT_SCHED();
	  
	  // Mettre peut être le signal() après les new_proc selon la dernière question ? 
	  // signal(SIGALRM,&commut);
	  
	  // Initialise l'instance a zero
		// instance_Timer[Nombre_Timer].it_interval.tv_sec 	= 0;
		// instance_Timer[Nombre_Timer].it_interval.tv_usec 	= 10000;
		// instance_Timer[Nombre_Timer].it_value.tv_sec 		= 0;
		// instance_Timer[Nombre_Timer].it_value.tv_usec 		= 10000;

		// setitimer(ITIMER_REAL, &instance_Timer[Nombre_Timer], NULL);
		
	  
	  if(mysetjmp(SCHED_PROC)==0){
		
		new_proc(Tache1,BEGIN_PROC);
		new_proc(Tache2,BEGIN_PROC+1);
		new_proc(Tache3,BEGIN_PROC+2);
		new_proc(Tache4,BEGIN_PROC+3);    


		// alarm(1);
		int p = election();
		mylongjmp(p);
	  }
	  else{
		// Fin d'un processus    
		int p = election();
		mylongjmp(p);
	  }
	  
	  
	}

	
	
	void Erreur_Fatale(int signalnum) {
		rest_scr0();
		
		printf(" !!! ERREUR FATALE !!!\n");
		
		printf(" * Thread en cours : %d\n", Thread_en_cours);
		printf(" * Erreur numero:%d\n * Info : ");
		
		if(signalnum == SIGABRT)
			printf("Arret du programme.\n");
		if(signalnum == SIGILL)
			printf("Instruction illegale.\n");
		if(signalnum == SIGINT)
			printf("Interruption utilisateur.\n");
		if(signalnum == SIGSEGV)
			printf("Violation segmentation de memoire.\n");
		if(signalnum == SIGALRM)
			printf("Alarme.\n");

		printf(" * Autres informations:\n\n", signalnum);
		exit(0);
	}
	

	int initialisation(){
		
		// myhandle[0].sa_handler = Erreur_Fatale;
		// sigemptyset(&myhandle[0].sa_mask);
		// myhandle[0].sa_flags = 0;
		// sigaction(SIGSEGV, &myhandle[0], NULL);
		
		// myhandle[1].sa_handler = Erreur_Fatale;
		// sigemptyset(&myhandle[1].sa_mask);
		// myhandle[1].sa_flags = 0;
		// sigaction(SIGILL, &myhandle[1], NULL);
		
		// myhandle[2].sa_handler = Erreur_Fatale;
		// sigemptyset(&myhandle[2].sa_mask);
		// myhandle[2].sa_flags = 0;
		// sigaction(SIGABRT, &myhandle[2], NULL);
		
		// myhandle[3].sa_handler = Erreur_Fatale;
		// sigemptyset(&myhandle[3].sa_mask);
		// myhandle[3].sa_flags = 0;
		// sigaction(SIGTRAP, &myhandle[3], NULL);
		
		// myhandle[4].sa_handler = Erreur_Fatale;
		// sigemptyset(&myhandle[4].sa_mask);
		// myhandle[4].sa_flags = 0;
		// sigaction(SIGINT, &myhandle[4], NULL);
		
	  if(sigsetjmp(proc[INIT_PROC].buf, 1) == 0) {
		start_sched();
	  }
	  else {
		printf("\n\n\n ****************** Retour au main, fin du programme ***************** \n\n\n");
	  }

	  return EXIT_SUCCESS;
	}
	
void printf_gcc(char* texte)
	{
		printf(texte); fflush(stdout);
	}
	
	bool end_Thread(unsigned int pid)
	{
		// Cette fonction permet de stopper un thread
		
		// Ne doit pas etre interrompu
		begin_SectionCritique();
	
		// Si pid = 0 alors il s'agit du thread courant
		if(pid == 0)
			pid = Thread_en_cours;
		
		// Mettre le thread en etat STOP = 0
		Liste_Threads[pid].Etat_Thread = STOP;
		
		// Vider son stack (Sa memoire ESP)
		// for(int b = 0; b <= MAX_STACK-1; b++)
			// Liste_Threads[pid].Stack_Thread[b] = ;
		
		// Vider les registres principaux
		Liste_Threads[pid].Buffer_Thread[0].__esp = 0;
		Liste_Threads[pid].Buffer_Thread[0].__eip = 0;
		
		// Priorite par defaut
		Liste_Threads[pid].TID = 0;
		
		// Et remettre son TID a zero
		Liste_Threads[pid].Priorite = 0;
		
		// Reduire le nombre de threads
		Nombre_Threads--;
		
		// Reprise du scheduler
		end_SectionCritique();
		
		return true;
	}
  
	void begin_SectionCritique()
	{
		SECTION_CRITIQUE = true;
	}
	
	void end_SectionCritique()
	{
		SECTION_CRITIQUE = false;
	}
	
	bool state_SectionCritique()
	{
		return SECTION_CRITIQUE;
	}
	
	
	unsigned int get_NombreThreads()
	{
		// Retourner le nombre de threads en cours
		return Nombre_Threads;
	}
	unsigned int get_NombreTimer()
	{
		// Retourner le nombre de timer executes
		return Nombre_Timer;
	}
	unsigned int get_ThreadEnCours()
	{
		// Retourner la thread en cours
		return Thread_en_cours;
	}
	
	bool initialiser_PIT(int frequence, int Intervalle_INTERNE)
	{
		// Cette fonction permet de reprogrammer l'intervalle du PIT
		//  -1:Pas de modification de la frequence
		//   0:Frequence MAX par defaut
		//	>0:Modification de la frequence d'horloge du PIT (Max:65535)
		
		if(frequence == 0)
		{	
			outportb(0x43, 0x36);
			outportb(0x40, 0);
			outportb(0x40, 0);
		} 
		else if ((frequence > 0) && frequence <= 65535)
		{	
			outportb(0x43, 0x36);
			outportb(0x40, ((1193180L / frequence) & 0x00ff));
			outportb(0x40, (((1193180L / frequence) >> 8) & 0x00ff));
		}
		
		// Modification du clock de la routine interne
		__djgpp_clock_tick_interval = Intervalle_INTERNE;
		
		return true;
	}
	
	
	
	bool initialiser_Multitache()
	{	
		// Va permettre de creer le thread MAIN
		// fb_InitSignals( );
		
		
		// Interdire toutes interruptions
		begin_SectionCritique();
		
		for(int ppb = 0; ppb <= 12; ppb++)
			for(int b = 0; b <= MAX_STACK-1; b++)
				Liste_Threads[ppb].Stack_Thread[b] = (char*) malloc(1024);
	
		// Point d'atthread
		setjmp(Liste_Threads[0].Buffer_Thread);
		
		// Stack du contexte
		Liste_Threads[0].Buffer_Thread[0].__esp = (unsigned int) Liste_Threads[0].Stack_Thread + MAX_STACK;  
		
		// Adresse du debut
		Liste_Threads[0].Buffer_Thread[0].__eip = (unsigned int) Thread_MAIN; 
		
		// Priorite
		Liste_Threads[0].Priorite = 127;
		
		// Son numero de TID (Thread IDentifiant)
		Liste_Threads[0].TID = 0;
		
		// Etat en execution (A modifier en PAUSE)
		Liste_Threads[0].Etat_Thread = EXECUTION;
		
		printf(" Info : Ajout du thread MAIN No %d emplacement %d\n", 0, (unsigned int) Thread_MAIN);
		
		// instance_SigAction

		myhandle[0].sa_handler = Erreur_Fatale;
		sigemptyset(&myhandle[0].sa_mask);
		myhandle[0].sa_flags = 0;
		sigaction(SIGSEGV, &myhandle[0], NULL);
		
		myhandle[1].sa_handler = Erreur_Fatale;
		sigemptyset(&myhandle[1].sa_mask);
		myhandle[1].sa_flags = 0;
		sigaction(SIGILL, &myhandle[1], NULL);
		
		myhandle[2].sa_handler = Erreur_Fatale;
		sigemptyset(&myhandle[2].sa_mask);
		myhandle[2].sa_flags = 0;
		sigaction(SIGABRT, &myhandle[2], NULL);
		
		myhandle[3].sa_handler = Erreur_Fatale;
		sigemptyset(&myhandle[3].sa_mask);
		myhandle[3].sa_flags = 0;
		sigaction(SIGTRAP, &myhandle[3], NULL);
		
		myhandle[4].sa_handler = Erreur_Fatale;
		sigemptyset(&myhandle[4].sa_mask);
		myhandle[4].sa_flags = 0;
		sigaction(SIGINT, &myhandle[4], NULL);
	
		
		// Reexecuter le scheduler normalement
		end_SectionCritique();
		
		// Retourner l'ID
		return true;
	} 

	unsigned int ajouter_Thread(unsigned int Fonction, int Priorite)
	{
		// Cette fonction permet d'ajouter une thread (Thread)
		
		
		// Si on atteint le nombre maximum de threads
		if(Nombre_Timer >= MAX_TIMERS)
		{
			printf(" ERREUR : Nombre maximum de threads autorise est de %d.", MAX_TIMERS);
			return 0;
		}
		
		// Interdire toutes interruptions
		begin_SectionCritique();
		
		// Incremente le nombre de threads
		Nombre_Threads++;
		
		int Nouveau_TID = 0;
		
		// Rechercher un emplacement ID vide
		for(int b = 1; b < MAX_THREAD; b++)	
			if(Liste_Threads[b].TID == 0)
			{
				Nouveau_TID = b;
				break;
			}
				
		if(Nouveau_TID == 0)
		{
			printf(" ERREUR : Impossible d'attribuer un nouveau TID.");
			return 0;
		}
	
		// Point d'atthread
		setjmp(Liste_Threads[Nouveau_TID].Buffer_Thread);
		
		// Stack du contexte
		Liste_Threads[Nouveau_TID].Buffer_Thread[0].__esp = (unsigned int) Liste_Threads[Nouveau_TID].Stack_Thread + MAX_STACK;  
		
		// Adresse du debut
		Liste_Threads[Nouveau_TID].Buffer_Thread[0].__eip = (unsigned int) Fonction; 
		
		// Priorite
		Liste_Threads[Nouveau_TID].Priorite = Priorite;
		
		// Son numero de TID (Thread IDentifiant)
		Liste_Threads[Nouveau_TID].TID = Nouveau_TID;
		
		// Etat en execution (A modifier en PAUSE)
		Liste_Threads[Nouveau_TID].Etat_Thread = EXECUTION;
		
		printf(" Info : Ajout du thread No %d emplacement %d\n", Nouveau_TID, (unsigned int) Fonction);
		
		
		
		// Reexecuter le scheduler normalement
		end_SectionCritique();
		
		// Retourner l'ID
		return Nouveau_TID;
	}
	
	
	unsigned int ajouter_Timer(unsigned int fonction)
	{
		// Cette fonction permet d'ajouter un Timer
		
		// Si on atteint le nombre maximum de timers
		if(Nombre_Timer >= MAX_TIMERS)
		{
			printf(" ERREUR : Nombre maximum de timer autorise est de %d.", MAX_TIMERS);
			return 0;
		}
		
		// NE PAS laisser le scheduler switcher pendant cette operation
		begin_SectionCritique();
		
		// Incremente le nombre de timers
		Nombre_Timer++;
		
		
		// Initialise l'instance a zero
		// instance_Timer[Nombre_Timer].it_interval.tv_sec 	= 0;
		// instance_Timer[Nombre_Timer].it_interval.tv_usec 	= 0;
		// instance_Timer[Nombre_Timer].it_value.tv_sec 		= 0;
		// instance_Timer[Nombre_Timer].it_value.tv_usec 		= 0;

		// Definir le timer
		// signal(SIGALRM, (void (*)(int)) fonction);
		// setitimer(ITIMER_REAL, &instance_Timer[Nombre_Timer], NULL);
		
		// instance_SigAction[0].sa_handler = (void (*)(int)) fonction;
		// sigemptyset(&instance_SigAction[0].sa_mask);
		// instance_SigAction[0].sa_flags = 0;
		// sigaction(SIGALRM, &instance_SigAction[0], NULL);

		// FB_SETUPSIGNAL(SIGINT, gen_handler)
		
		// Reexecuter le scheduler normalement
		end_SectionCritique();
		
		// Retourner l'ID
		return Nombre_Timer;
	}
	

	bool demarrer_SCHEDULER(unsigned int id_TIMER, int temps_us)
	{
		// Cette fonction permet de demarrer le scheduling d'un timer 
		//  en definissant le temps en intervalle en micro-secondes
		
		return true;
		// s'il y en a pas, retour!
		if(Nombre_Timer < 1) 
			return false;
		
		// Definir l'intervalle
		instance_Timer[id_TIMER].it_interval.tv_sec 	= 0;
		instance_Timer[id_TIMER].it_interval.tv_usec 	= temps_us;
		instance_Timer[id_TIMER].it_value.tv_sec 		= 0;
		instance_Timer[id_TIMER].it_value.tv_usec 		= temps_us;
		
		// On envoie tout ca
		setitimer(ITIMER_REAL, &instance_Timer[id_TIMER], NULL);
		
		return true;
	}

	bool stop_SCHEDULER(int id_TIMER)
	{
		// Cette fonction permet d'arreter le scheduler

			return true;
			
		// Initialise l'instance a zero
		instance_Timer[id_TIMER].it_interval.tv_sec = 0;
		instance_Timer[id_TIMER].it_interval.tv_usec = 0;
		instance_Timer[id_TIMER].it_value.tv_sec = 0;
		instance_Timer[id_TIMER].it_value.tv_usec = 0;
		
		// On envoie tout ca
		setitimer(ITIMER_REAL, &instance_Timer[id_TIMER], NULL);
		
		return true;
	}
	
 
	void Interruption_Timer(int sig)
	{		
		// Interruption du timer
		if(Est_Interruption() == true)
			return;
		
		// if(Is_In_Interrupt() == true)
			// return;
			
		
		
		// afficher();
		// __dpmi_yield();

		
		if(SECTION_CRITIQUE == false)
			switch_context();
		
	}

	int saut_int = 0;

	void switch_context()
	{
		saut_int++;
		// if(Est_Interruption() == true)
			// return;
		
		// if(SECTION_CRITIQUE == true)
			// return;
		
		
		__dpmi_yield();

		if(saut_int > 12)
		{
			saut_int = 0;
			commut(0);
		}

		
		return;
	// On passe a une autre thread!
		
		// char* texte = (char*) malloc(64);

		// afficher();
	
		// Si le nombre de thread est inferieur a 2 (donc 1 ou 0)
		//  il est inutile de switcher
		if(Nombre_Threads < 1) return;
		
		
	
		
		// Si le thread est pas vide
		if(Liste_Threads[Thread_en_cours].Etat_Thread != STOP)
		{
			// Recuperer les info (registres...) du thread actuel
			if (sigsetjmp(Liste_Threads[Thread_en_cours].Buffer_Thread ,1) == 1)
			{
				
				return;
			}
		}

		// On cherche quel prochain thread (TID) a executer
		Thread_en_cours++;
		
		if (Thread_en_cours >= MAX_THREAD)
			Thread_en_cours = 0;
		
		
		// Si le prochain thread n'est pas STOPPE ni en PAUSE
		while(Liste_Threads[Thread_en_cours].Etat_Thread != EXECUTION)
		{
			Thread_en_cours++;
			
			if (Thread_en_cours >= MAX_THREAD)
				Thread_en_cours = 0;
		}


		// Reexecuter le scheduler normalement
		end_SectionCritique();
		
		// std::cout << "  --> eip(" << Thread_en_cours << "):" << Liste_Threads[Thread_en_cours].Buffer_Thread[0].__eip << std::endl;
		// std::cout << "  --> esp    " << Liste_Threads[Thread_en_cours].Buffer_Thread[0].__esp << std::endl;
		
		// On execute le prochain thread
		siglongjmp(Liste_Threads[Thread_en_cours].Buffer_Thread, 1);
		
	}
	
	void loop_MAIN()
	{
		// Cette fonction permet creer un point de terminaison du main en executant
		//  la premiere thread
		Thread_en_cours = 0;
		longjmp(Liste_Threads[0].Buffer_Thread, 1);	
	}
	
	void raise_dj()
	{
		// raise(SIGFPE);
	}
	
} // namespace

extern "C" void switch_context__()
{
	// NP_cpinti_mt::switch_context();
}

/*
// [FR] Ajouter un Timer handler
// [EN] Add timer handler
int id_TIMER = ajouter_TIMER((unsigned int) Interruption_Timer);

// [FR] Demarrer le scheduling du timer precedement (Intervalle de 100us)
// [EN] Starting my timer scheduling (100 us interval)
demarrer_SCHEDULER(id_TIMER, 100);

// [FR] Creer mes threads
// [EN] Create my threads
Ajouter_Thread((unsigned int) Thread_1);
Ajouter_Thread((unsigned int) Thread_2);
Ajouter_Thread((unsigned int) Thread_3);

// Loop
loop_MAIN();  return 0;
*/