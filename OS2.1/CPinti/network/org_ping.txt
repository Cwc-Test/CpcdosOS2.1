/*	
	======================================
	==       CPinti ---> PING ICMP      ==
	======================================
	
	Developpe entierement par Sebastien FAVIER

	Description
		Module permettant de pinger une machine sur le reseau
		Utilise le protocole ICMP.
	
	Creation
		19/10/2016
		
	Reecriture
		02/11/2016

	Mise a jour
		29/01/2018
		
		29-01-2018	: CORRECTION du calcul du temps qui etait basé sur la trame reçue et non la trame d'envoie
		07-12-2017	: AMELIORATION du code en suivant une procedure sticte de GCC
		05-01-2017  : Correction du probleme de reception de la trame (return mal place)
					: Correction des 4 octets en trop dans la trame 
						memcpy(&this->PAQUET_ICMP[TAILLE_ICMP_HDR+TAILLE_Temps_Debut+TAILLE_PAQUET_ENVOYE##-4##] --> "-4" supprime!

*/


#include <ctime>
#include <cstdlib>
#include <cstring>
#include <memory>
#include <ctime> // RAND()
#include <unistd.h> // usleep

#include "func_cpi.h"
#include "debug.h"
#include "socket.h"
#include <netinet/ip_icmp.h>
#include "ping.h"
#include "core.h"



namespace NP_cpinti_ping
{
	int cpinti_ping::Demarrer_ping(std::string IP_machine, std::string Message, int Param)
	{
		// Cette fonction permet de pinger une machine sur le reseau afin de tester sa presence
		//  IP_machine 	= Adresse IP distante
		//  Message		= Message de la trame ICMP personnalisee ;)
		
		// Retourne :
		//	0	: OK
		// 	-1 	: La machine n'a pas repondu
		//	-2	: Erreur de configuration du socket
		//	-3	: Impossible de creer un socket (Driver manquant?)
		//	-4	: Erreur de binding
		//	-5	: Ecoute impossible
		//	-6	: Erreur de descripteur de fichier (select())
		//	-7	: Erreur de lecture de socket (ERRPIPE)
		//  -8	: Impossible de resoudre le nom (DNS)
		//	-9	: Memoire insuffisante
		
		int Resultat_Preparation_SOCKET 		= 0;
		unsigned int Resultat_Preparation_TRAME = 0;
		int Resultat_TRANSMISSION 				= 0;
		int Resultat_RECEPTION 					= 0;
		long Temps_total						= 0;
		std::string Temps_total_STR;
		
		
		/**** Stocker le message dans un membre de la classe pour avoir un pointeur LOCAL ****/
		this->STR_Message_ICMP = Message;
		this->Message_ICMP 	= this->STR_Message_ICMP.c_str();
		

		/*********************************************************************************/
		/********* Allocation memoire d'une nouvelle instance d'un socket reseau *********/
		/*********************************************************************************/

		cpinti_dbg::CPINTI_DEBUG(" * Allocation memoire d'une instance d'un socket... ", 
					 " * Memory allocation for network socket... ",
						"cpinti_ping", "Demarrer_ping", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
		
		std::unique_ptr<NP_cpinti_socket::cpinti_socket> instance_socket(new NP_cpinti_socket::cpinti_socket);
		
		// Verifier si l'allocation a echoue
		if (instance_socket == NULL)
		{
			std::string Erreur_mem = std::string(strerror(errno));
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible d'allouer de la memoire.\n Raison '" + Erreur_mem + "'", 
						"[ERROR] Unable to allocate memory.\n Reason '" + Erreur_mem + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);

			return PING_ERR_MEM; 
		} /* Erreur de memoire */
		
		
		std::string ADR = "0x" + std::to_string((unsigned int) &instance_socket);
		std::string SIZ = std::to_string((int) sizeof(instance_socket));
		cpinti_dbg::CPINTI_DEBUG("[OK] --> Allocation offset:" + ADR + " taille:" + SIZ + " octets.", "[OK] --> Allocation offset:" + ADR + " size:" + SIZ + " bytes.", 
						"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
		
		// Ok, on verifie si la preparation du socket a echoue
		Resultat_Preparation_SOCKET = Preparer_Socket(instance_socket, IP_machine, Param);
		
		// Si il y a un soucis, le message d'erreur est deja logge, on quitte.
		if(Resultat_Preparation_SOCKET < 0)
			return Resultat_Preparation_SOCKET;
		
		// 14-11-2016 - OK
		
		// **** Obtenir le temps de depart pour le comptage ****
		gettimeofday (&this->Temps_Depart, &this->Temps_Zone);
		
		// Preparer la trame ICMP
		Resultat_Preparation_TRAME = Preparer_Trame();
		if(Resultat_Preparation_TRAME <= 0)
			return (int) Resultat_Preparation_TRAME;
		
		// Transmettre la trame ICMP
		Resultat_TRANSMISSION = Transmission(instance_socket, Resultat_Preparation_TRAME);
		if(Resultat_Preparation_TRAME <= 0)
			return Resultat_TRANSMISSION;
		
printf(" P0 \n");
		// Attendre la reponse de la machine
		Resultat_RECEPTION = Reception(instance_socket, Param);
		
printf(" P1 \n");
		// Fermer le socket reseau maintenant qu'on ne s'en servira plus! :)
		Fermer_Socket(instance_socket);
		
		if(Resultat_RECEPTION < 0)
			return PING_NO_REP; // pas de reponse
		
		else // Reponse!
		{
		
printf(" P5 \n");		
			// Recuperer le temps mis
			// gettimeofday (&this->Temps_Depart, &this->Temps_Zone);
			// memcpy (&this->Temps_Envoie, &this->TRAME_ICMP->icmp_data, sizeof(Temps_Envoie));
			
			// Comparer le temps de d'envoie et de reception
			// Temps_total = cpinti::Func_Cpinti::Comparer_Temps (&this->Temps_Actuel, &this->Temps_Envoie);
			Temps_total = cpinti::Func_Cpinti::Comparer_Temps (&this->Temps_Actuel, &this->Temps_Depart);

printf(" P6 \n");	
			// Si le chiffre est negatif on le recalle au positif
			if(Temps_total < 0)
				Temps_total = 0 - Temps_total;
			
			Temps_total_STR = std::to_string(Temps_total);
printf(" P7 \n");				 
			cpinti_dbg::CPINTI_DEBUG(" Temps:" + Temps_total_STR + " ms.", " Time:" + Temps_total_STR + " ms.",
								"", "", Ligne_saute, Alerte_validation, Date_sans, Ligne_r_normal);
			
			return (int) Temps_total;
		}
	}
	
	unsigned int cpinti_ping::Preparer_Trame()
	{
		// Cette fonction permet de preparer la trame ICMP afin que les routeurs et machines la comprennent
		//  Retourne
		//		Taille de la trame.
		
		
		// Recuperer la taille du message perso
		size_t Taille_Message;
		int Nombre_paquets_envoyes = 1; // On envoie qu'une seule trame!
		
		size_t TAILLE_ICMP_HDR, TAILLE_PAQUET_ENVOYE, TAILLE_Temps_Debut, TAILLE_Finale;
		
		cpinti_dbg::CPINTI_DEBUG("Preparation de la trame ICMP... ",
								"Preparation of the ICMP frame... ",
								"", "", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
		
		
		// Initialiser la trame PAR DEFAUT
		this->TRAME_ICMP->icmp_type		= REQUETE_ICMP; 	/* 0x08 */
		this->TRAME_ICMP->icmp_code		= CODE_ICMP;		/* 0x00 */
		this->TRAME_ICMP->icmp_cksum	= CHECKSUM_ICMP;	/* 0x00 */
		this->TRAME_ICMP->icmp_seq		= SEQUENCE_ICMP;	/* 0x00 */
		this->TRAME_ICMP->icmp_id		= ID_ICMP;			/* 0x00 */
		
		// Nombre aleratoire base sur l'horloge du systeme
		srand (time(NULL));
		
		// Enseigner un identifiant unique a la trame via un nombre aleatoire
		this->TRAME_ICMP->icmp_id = (rand() % 65500 + 1) & 0xFFFF; // 6 501 possibilites c'est deja pas mal hein!
		
		// Faire un calcul total de la taille du futur paquet
		TAILLE_ICMP_HDR 		= REQUETE_ICMP; // Toujours egale a 8
		TAILLE_PAQUET_ENVOYE 	= sizeof(Nombre_paquets_envoyes);
		TAILLE_Temps_Debut		= sizeof(this->Temps_Depart);
		Taille_Message 			= STR_Message_ICMP.size(); /* -2 pour corriger l'espace en trop */
		
		// Total 
		TAILLE_Finale			= TAILLE_ICMP_HDR + TAILLE_PAQUET_ENVOYE + TAILLE_Temps_Debut + Taille_Message ;
		
		// Insertion des octets dans la trame
		memcpy(&this->PAQUET_ICMP[TAILLE_ICMP_HDR], &this->Temps_Depart, TAILLE_Temps_Debut);
		memcpy(&this->PAQUET_ICMP[TAILLE_ICMP_HDR+TAILLE_Temps_Debut], &Nombre_paquets_envoyes, TAILLE_PAQUET_ENVOYE);
		memcpy(&this->PAQUET_ICMP[TAILLE_ICMP_HDR+TAILLE_Temps_Debut+TAILLE_PAQUET_ENVOYE], this->Message_ICMP, Taille_Message);
		
		// Generer le checksum original de la trame ICMP
		//  afin de verifier si la transimission reseau n'a pas corrompu la trame.
		this->TRAME_ICMP->icmp_cksum = cpinti::Func_Cpinti::Generer_CheckSum((void*) this->TRAME_ICMP, TAILLE_Finale);
		
		std::string TAILLE_STR 	= std::to_string(TAILLE_Finale);
		std::string SUM_STR 	= std::to_string(this->TRAME_ICMP->icmp_cksum);
		
		// Log 
		cpinti_dbg::CPINTI_DEBUG("[OK] --> Taille:" + TAILLE_STR + " [chksum:" + SUM_STR + "]",
								"[OK] --> Size:" + TAILLE_STR + " [chksum:" + SUM_STR + "]",
								"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
								
		// Retourner la taille total de la trame
		return (unsigned int) TAILLE_Finale;
	}
	
	int cpinti_ping::Transmission(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket, unsigned int Taille)
	{
		// Cette fonction permet de transmettre le paquet sur le reseau

		cpinti_dbg::CPINTI_DEBUG("Transmission du paquet a " + instance_socket->get_NOM_dest() + "(" + instance_socket->get_IP_dest() + ")... ",
								"Sending packet to " + instance_socket->get_NOM_dest() + "(" + instance_socket->get_IP_dest() + ")... ",
								"", "", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
								
		// Envoyer la trame sur le reseau
		if(instance_socket->Envoyer_TRAME(Taille, (const void*) this->PAQUET_ICMP) == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Reseau non disponible.\n Raison '" + instance_socket->get_Erreur() + "'",
								"[ERROR] Not avaiable network.\n Reason '" + instance_socket->get_Erreur() + "'",
								"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
			return PING_NO_RES; // Envoi impossible
		}
		
		
		cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]",
								"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
								
		return PING_OK; // Transmission OK
	}
	
	int cpinti_ping::Reception(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket, int Param)
	{
		// Cette fonction permet de receptionner une requete sur le reseau
		
		ENTRER_SectionCritiqueMT();
		if(Param) Param = 0;
		
		// Receptionner la reponse
		cpinti_dbg::CPINTI_DEBUG("Attente d'une reponse", 
								"Waiting for a response",
								"", "", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
								
		// Preparation de la reception de la trame (Descripteur de fichier)
		if(instance_socket->Preparer_reception_TRAME() == false)		
			return PING_NO_REP; // Pas de reponse!
		
		printf("P1\n");
		cpinti_dbg::CPINTI_DEBUG("... ", "... ",
								"", "", Ligne_reste, Alerte_action, Date_sans, Ligne_r_normal);
								
		printf("P2\n");
		if(instance_socket->Recevoir_TRAME() == false)
		{ 
			// Pas repondu
			cpinti_dbg::CPINTI_DEBUG(" Pas de reponse.", " No response.",
								"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
			SORTIR_SectionCritiqueMT();
			return PING_NO_REP;
		}
		else
		{	// OK 
			printf("P3\n");
			cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]",
								"", "", Ligne_reste, Alerte_validation, Date_sans, Ligne_r_normal);
			printf("P4\n");
			SORTIR_SectionCritiqueMT();
			return PING_OK; // Temporaire
		}
	}
	
	int cpinti_ping::Fermer_Socket(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket)
	{
		// Fermer la connexion
		
		if(instance_socket->Fermer_socket()==false)
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Lors de la fermeture du socket.\n Raison '" + instance_socket->get_Erreur() + "'",
								"[ERROR] During socket closing.\n Reason '" + instance_socket->get_Erreur() + "'",
								"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
	
	
		return PING_OK;
	}
	
	
	int cpinti_ping::Preparer_Socket(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket, std::string IP_machine, int Param)
	{
		
		if(Param) Param = 0;
		
		/**** Stocker l'adresse IP (ou nom) destinataire ****/
		instance_socket->set_IP_dest(IP_machine);

		cpinti_dbg::CPINTI_DEBUG(" * Creation d'un nouveau socket reseau... ", 
				 " * Creating new network socket... ",
					"cpinti_ping", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);

		/*********************************************************************************/
		/**************** Creer une nouvelle socket dans la classe Socket ****************/
		/*********************************************************************************/
		
		if(instance_socket->Initialiser_socket(INIT_PING_ICMP) == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de creer un socket reseau.\n Raison '" + instance_socket->get_Erreur() + "'", 
						"[ERROR] Unable to create network socket.\n Reason '" + instance_socket->get_Erreur() + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
						
			return PING_ERR_INIT_SOCK; // 
		} /* Impossible de creer un socket */

		
		cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]", 
					"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
			
		cpinti_dbg::CPINTI_DEBUG(" * Configuration du socket reseau... ", 
				 " * Configuration network socket... ",
					"cpinti_ping", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);

					
		/*********************************************************************************/
		/*** Configurer le socket par rapport au type selectionne --> "INIT_PING_ICMP" ***/
		/*********************************************************************************/
		
		if(instance_socket->Configurer_socket() == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de configurer le socket reseau.\n Raison '" + instance_socket->get_Erreur() + "'", 
						"[ERROR] Unable to create network socket.\n Reason '" + instance_socket->get_Erreur() + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
						
			return PING_ERR_CONFIG_SOCK;
		} /*  Erreur de configuration du socket */
		
		
		cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]", "", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);

		
		/*********************************************************************************/
		/*************** Verifier/Traduire si c'est un NOM DE SERVEUR ********************/
		/*********************************************************************************/
		
		// if(NP_cpinti_socket::cpinti_socket_LOCAL::TestAdresseIPv4(instance_socket->get_IP_dest()) == false) 
			
		// On stocke le nom d'origine de cote
		instance_socket->set_NOM_dest(instance_socket->get_IP_dest());
		
		// On avertit l'operation a l'utilisateur hein soyons pas egoiste! ;)
		cpinti_dbg::CPINTI_DEBUG(" * Resolution DNS si possible de '" + instance_socket->get_NOM_dest() + "'... ", 
				 " * DNS resolution if possible '" + instance_socket->get_NOM_dest() + "'... ",
					"cpinti_ping", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
					
		
		std::string DNS_Resultat;
		
		/**** Traduire si possible en adresse IP ****/
		DNS_Resultat = instance_socket->Resolution_DNS(instance_socket->get_NOM_dest());
		
		// Verifier s'il y a eu une erreur
		if(DNS_Resultat.compare("#ERR")==0)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de resoudre le nom de serveur\n Raison '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur(), 
					"[ERROR] Unable to resolve name server\n Reason '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur(),
					"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);

			return PING_ERR_NOM_DNS; // Impossible de resoudre le nom
		}
		else
		{
			// La traduction s'est bien faite!
			//  On stocke l'IP du serveur
			instance_socket->set_IP_dest(DNS_Resultat);
			
			cpinti_dbg::CPINTI_DEBUG(" [OK] --> " + instance_socket->get_IP_dest(), 
						" [OK] --> " + instance_socket->get_IP_dest(),
						"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
		}

		/*********************************************************************************/
		/****************** Binder le socket pour le rendre utilisable *******************/
		/*********************************************************************************/

		cpinti_dbg::CPINTI_DEBUG(" * Bindage du socket reseau... ", 
				 " * Binding network socket... ",
					"cpinti_ping", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);

		
		if(instance_socket->Binder_socket() == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de binder le socket\n Raison '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur(), 
						"[ERROR] Unable to binding socket\n Reason '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur(),
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);

				return PING_ERR_BIND_SOCK; // Impossible de binder le socket
		}
		else
			cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]" ,
							"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);


		return 0; // Preparation du socket OK

	} /* PREPARER_SOCKET */
}














