' Contient des fonctions et variables concernant 
' Cpcdos en general

' Par Sebastien FAVIER
' Reecriture le 13/10/2016
' Mise a jour le 16/10/2018

' 16-10-2018	: Adaptation 2.1 beta 1.1
' 31-10-2017	: AJOUT des LTRIM et RTRIM sur les tabulations, espaces et CR & LF des noms de fichiers/path

#print Spinti Software Cpcdos OSx Cree Pour Concevoir Des OS
#print Par FAVIER Sebastien COPYRIGHT(C)SPINTI SOFTWARE

REM ====================================================
REM Developpe par : SPinti Software - Sebastien FAVIER
REM =====================================================
REM Copyright(C)Spinti Software. SPinti Software(TM)
REM Source protege par les droits d'auteur (Dossier No:J8781B5)
REM =====================================================

#define FBCALL

#include once "Cpcdos.bi"

#print
#print ============ Cpcdos ==============
' **** Instanciations **** 	
Dim SHARED CPCDOS_INSTANCE as __Noyau_Cpcdos_OSx__

' Constructeur prioritaire
Sub __CPCDOSOSX() Constructor 101
	_Memoire_Libre_Depart = fre
	DEBUG(" * Preparation du demarrage des modules du noyau", 1, 1, 15, 0, 0, 1, 0, "")
	print ' Probleme de CR-LF par ce que le module DEBUG n'est pas charge	
		
	LA_DATE = "28/03/95"
	L_HEURE  = "17:23:16"
End sub

' Dernier destructeur 
Sub __END_CPCDOSOSX() Destructor 65535
	DEBUG(" * Dechargement des modules du noyau... [OK]", 1, 1, 6, 0, 0, 1, 0, "")
End sub

Constructor __Noyau_Cpcdos_OSx__()
	DEBUG(" * Instanciation du noyau Cpcdos --> Allocation offset:0x" & hex(@this) & " Taille:" & SizeOf(this) & " octets", 1, 1, 2, 0, 0, 1, 0, "")
End Constructor

Destructor __Noyau_Cpcdos_OSx__()
	DEBUG(" * De-instanciation du noyau Cpcdos --> Desallocation offset:0x" & hex(@this), 1, 1, 6, 0, 0, 1, 0, "")
End Destructor

Constructor _TYPES_Cpcdos_OSx__()
	DEBUG(" * Instanciation des Types --> Allocation offset:0x" & hex(@this) & " Taille:" & SizeOf(this) & " octets ", 1, 1, 2, 0, 0, 1, 0, "")
	' intro()
End Constructor

Destructor _TYPES_Cpcdos_OSx__()
	' CPCDOS_INSTANCE.CPINTI_INSTANCE->destructor()
	DEBUG(" * De-instanciation des Types --> Desallocation offset:0x" & hex(@this), 1, 1, 6, 0, 0, 1, 0, "")
End Destructor


function nearbyint (byval x as double) as double
	' Wrapper de compatibilite
	nearbyint = rint(x)
End function

#print * Generateurs d identifiants numeriques et Authentifications
Sub __Noyau_Cpcdos_OSx__.Generer_id_kernel()
	' Cette fonction permet de generer un ID_KERNEL unique entre 1000 et 9999
	'  qui servira pour autentification de base du systeme via l'instance en cours
	' Ce qui permet aussi l'instance propre de plusieurs simultanes ;)
	
	this.ID_KERNEL = int(Generer_RND(1, 15))
End sub

Function __Noyau_Cpcdos_OSx__.Generer_cle_NIV_1(id_Kernel as uinteger, id_OS as uinteger, id_Util as uinteger) as double
		' Generer une cle finale de niveau 1 (Kernel, OS, Utilisateur)
		Dim kernel 	as String 	= STR(BIN(id_Kernel, 4)) 	' 4 bits
		Dim os 		as String 	= STR(BIN(id_OS	, 4)) 		' 4 bits
		Dim User 	as String 	= STR(BIN(id_Util	, 8)) 	' 8 bits

		Generer_cle_NIV_1 = Val("&B" & kernel & os & User) ' assembler les bits + convertir en decimal double
End Function

Function __Noyau_Cpcdos_OSx__.Generer_cle_NIV_2(id_PID as uinteger, id_TID as uinteger) as double
		' Generer une cle finale de niveau 1 (Kernel, OS, Utilisateur)
		Dim pid 	as String 	= STR(BIN(id_PID	, 8)) 		' 8 bits
		Dim tid 	as String 	= STR(BIN(id_TID	, 12)) 	' 12 bits
		
		Generer_cle_NIV_2 = Val("&B" & pid & tid) ' assembler les bits + convertir en decimal double
End Function

Function __Noyau_Cpcdos_OSx__.Generer_cle_ASM(CLE_NIV_1 as double, CLE_NIV_2 as double) as double
		' Generer une cle finale de niveau 1 (Kernel, OS, Utilisateur)
		Dim cle_1 	as String 	= STR(Bin(CLE_NIV_1)) 	' 16 bits
		Dim cle_2 	as String 	= STR(Bin(CLE_NIV_2)) 	' 20 bits
		
		Generer_cle_ASM = Val("&B" & cle_1 & cle_2) ' assembler les bits + convertir en decimal double
End Function

Function __Noyau_Cpcdos_OSx__.Generer_cle(id_Kernel as uinteger, id_OS as uinteger, id_Util as uinteger, id_PID as uinteger, id_TID as uinteger) as double
		' Generer une cle finale de niveau 1 (Kernel, OS, Utilisateur)
		Dim kernel 	as String 	= STR(BIN(id_Kernel, 4)) 	' 4 bits
		Dim os 		as String 	= STR(BIN(id_OS	, 4)) 	' 4 bits
		Dim User 	as String 	= STR(BIN(id_Util	, 8)) 	' 8 bits
	
		Dim pid 	as String 	= STR(BIN(id_PID	, 8)) 		' 8 bits
		Dim tid 	as String 	= STR(BIN(id_TID	, 12)) 	' 12 bits
		
		Generer_cle = Val("&B" & kernel & os & User & pid & tid) ' Assembler les bits + convertir en decimal double
End Function

Function __Noyau_Cpcdos_OSx__.get_id_kernel() as uinteger
	' Cette fonction importante, permet de retourner le numero d'identification du kernel
	'  genere precedement
	
	get_id_kernel = this.ID_KERNEL
End Function

Function __Noyau_Cpcdos_OSx__.get_id_kernel(CLE as double) as uinteger
	' Extraire le numero ID du kernel

	get_id_kernel = Val("&B" & MID(STR(Bin(CLE, 36)), 1, 4))
End Function

Function __Noyau_Cpcdos_OSx__.get_id_OS() as uinteger
	' Extraire le numero ID de l'OS
	get_id_OS = this.ID_OS
End Function

Function __Noyau_Cpcdos_OSx__.get_id_OS(CLE as double) as uinteger
	' Extraire le numero ID de l'OS
	get_id_OS = Val("&B" & MID(STR(Bin(CLE, 36)), 5, 4))
End Function

Function __Noyau_Cpcdos_OSx__.get_id_Utilisateur() as uinteger
	' Extraire le numero ID de l'USER
	get_id_Utilisateur = this.ID_UTIL
End Function

Function __Noyau_Cpcdos_OSx__.get_id_Utilisateur(CLE as double) as uinteger
	' Extraire le numero ID de l'USER
	get_id_Utilisateur = Val("&B" & MID(STR(Bin(CLE, 36)), 9, 8))
End Function

Function __Noyau_Cpcdos_OSx__.get_id_PID(CLE as double) as uinteger
	' Extraire le numero ID du processus
	get_id_PID = Val("&B" & MID(STR(Bin(CLE, 36)), 17, 8))
End Function

Function __Noyau_Cpcdos_OSx__.get_id_TID(CLE as double) as uinteger
	' Extraire le numero ID du Thread
	get_id_TID = Val("&B" & MID(STR(Bin(CLE, 36)), 25, 12))
End Function


Function __Noyau_Cpcdos_OSx__.Generer_RND(Debut as double, Fin as double) as double
	' Cette fonction permet de generer un nombre aleratoire sur une intervalle personnalisee

	Generer_RND = RND() * (Fin - Debut) + Debut
End function

#print * Processus
Function __Noyau_Cpcdos_OSx__.Creer_processus(NomProcessus as string) as uinteger
	' Cette focntion permet de creer un processus vierge, sans threads
	'	NomProcessus	: Nom du processus
	
	' Retourne le numero de PID du processus (Genere par CPinti Core)

	' Allouer un texte
	Dim NomProcessus_CHAR as CONST ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(NomProcessus)
	
	' Creer le processus via CPinti Core et recuperer le numero de PID
	Dim PID as uinteger = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_creer_processus(get_id_kernel(), NomProcessus_CHAR)
	
	' Desallouer le texte
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(NomProcessus_CHAR)
	
	' Renvoyer le numero de PID
	Creer_processus = PID
end Function


Function __Noyau_Cpcdos_OSx__.Fermer_processus(PID as uinteger) as integer
	' Cette fonction permet de fermer un processus et ses threads associes
	'	PID		: Numero de PID du processus
	
	' Changer l'etat afin que le gestionnaire de processus soit averti du declanchement
	Gerer_processus(PID, CPCDOS_INSTANCE.__EN_ARRET)
	
	' Enclancher l'arret en informant d'un etat ARRET
	CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_sortir_processus(get_id_kernel(), PID)
	
	' Fermer completement le processus et ses threads associes + nettoyage memoire
	Fermer_processus = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_arreter_processus(get_id_kernel(), PID)
	
End function

Function __Noyau_Cpcdos_OSx__.Gerer_processus(PID as uinteger, Action as integer) as integer
	' Cette fonction permet de changer l'etat du processus
	'	PID		: Numero de PID du processus
	'	Action	:
	' 		__EN_EXECUTION 	= 83 	' 0x53
	' 		__EN_PAUSE 		= 101 	' 0x65
	' 		__EN_ATTENTE 	= 98 	' 0x62
	' 		__EN_ARRET 		= 70	' 0x46
	
	' Envoyer la requete a CPinti Core et retourner le resultat
	Gerer_processus = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_gerer_processus(get_id_kernel(), PID, Action)
	
End function


#print * Threads

Function __Noyau_Cpcdos_OSx__.Creer_thread(_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__) as uinteger
	' Cette fonction permet de creer un nouveau thread DANS un processus specifie
	'	NomThread	: Nom du thread
	'	PID			: PID du processus parent (hebergeur)
	' 	Fonction	: Adresse memoire DEBUT de la fonction
	' _ARG_1,2,3,4	: Arguments pour le thread
	
	' Renvoie le numero TID du thread corrrespondant au processus

	
	' Allouer le texte
	Dim NomThread_CHAR as CONST ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(_STRUCT_THREAD.Nom)


	function  = cpinti.gestionnaire_tache.cpinti_creer_thread(get_id_kernel(), _STRUCT_THREAD.OS_ID, _STRUCT_THREAD.USER_ID, _STRUCT_THREAD.PROC_ID, NomThread_CHAR, _STRUCT_THREAD.Priorite, _
																_STRUCT_THREAD.Fonction, _
																_STRUCT_THREAD.ARG_1, _
																@_STRUCT_THREAD)

	
	' Desallouer le texte
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(NomThread_CHAR)


End Function

Function __Noyau_Cpcdos_OSx__.Fermer_thread(PID as uinteger, TID as uinteger) as integer
	' Cette fonction permet de fermer un thread associe a un processus (envoie un signal)
	'	PID		: Numero PID du processus
	'	TID		: Numero TID du thread
	
	' Envoyer un signal d'arret au thread concerne via CPinti Core
	Gerer_thread(PID, TID, CPCDOS_INSTANCE.__EN_ARRET)
	
	' Arreter le thread
	Function = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_arreter_thread(get_id_kernel(), PID, TID)
End Function


Function __Noyau_Cpcdos_OSx__.Gerer_thread(PID as uinteger, TID as uinteger, Action as integer) as integer
	' Cette fonction permet de gerer les threads
	'	PID		: Numero PID du processus
	'	TID		: Numero TID du thread
	'	Action	:
	' 		__EN_EXECUTION 	= 83 	' 0x53
	' 		__EN_PAUSE 		= 101 	' 0x65
	' 		__EN_ATTENTE 	= 98 	' 0x62
	' 		__EN_ARRET 		= 70	' 0x46
	
	' Envoyer la requete a CPinti Core et recuperer le resultat
	Gerer_thread = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_gerer_thread(get_id_kernel(), PID, TID, Action)
End Function


Function __Noyau_Cpcdos_OSx__.get_Nom_Thread(PID as uinteger, TID as uinteger) as String
	' Cette fonction permet d'obtenir le nom d'un thread
	'	PID		: Numero PID du processus
	'	TID		: Numero TID du thread
	'   Retourne le nom du thread
	
	Dim Nom_Thread as ZString PTR
	
	CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_get_nom_thread(get_id_kernel(), PID, TID, Nom_Thread)
	
	' Retourner en String
	Function = *Nom_Thread
	
End Function

Function __Noyau_Cpcdos_OSx__.get_Nom_Processus(PID as uinteger) as String
	' Cette fonction permet d'obtenir le nom d'un thread
	'	PID		: Numero PID du processus
	'   Retourne le nom du processus
	
	Dim Nom_Processus as ZString PTR
	
	CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_get_nom_processus(get_id_kernel(), PID, Nom_Processus)
	
	' Retourner en String
	Function = *Nom_Processus
	
	' Et Vider sa memoire
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Nom_Processus)
End Function

#print * Lecture et ecriture de fichiers
Function __Noyau_Cpcdos_OSx__.Lire_fichier_complet(ByVal Chemin as String) as String
	' Cette fonction permet de lire un fichier complet
	'	Chemin	: Chemin d'acces au fichier
	' Retourne le contenu du fichier

	Chemin = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Chemin, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	
	Dim f As Integer = FreeFile
	Dim buffer as string
	Dim total as string
	Open Chemin For Input As #f
	
	
	Do Until EOF( f ) 
		buffer = ""
		line input #f, buffer
		total += buffer & CRLF
	Loop
	
	
	close #f

	
	Lire_fichier_complet = total
	exit function
	
	' Transformer en CHAR*
	Dim Chemin_CHAR as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Chemin)
	
	' Transformer en CHAR* 
	DIM MODE_CHAR as CONST ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString("RB")
	
	' Recuperer la  taille du fichier
	Dim Taille_Du_Fichier as uinteger = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Taille_Fichier(Chemin_CHAR)
	
	' Creation d'un nouveau pointeur
	Dim Buffer_CCP_CHAR as Zstring ptr = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString_0(Taille_Du_Fichier + 1)
	
	
	' Lire le fichier depuis CPinti Core
	Dim Resultat as uinteger = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Lire_Fichier_complet(Chemin_CHAR, MODE_CHAR, Buffer_CCP_CHAR)
	
	IF Resultat < 0 then
		' Sachant que le fichier est dabord teste, il s'agirait donc
		' d'une erreur interne de CPinti mais il concerne ce fichier
		Dim Message_erreur as String = ERRAVT("ERR_015", 0)
		DEBUG("[CpcdosC+] (CPinti core) : Erreur d'acces interne. " & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, "")
		
		Function = ""
	else
	
		' Transformer en String
		Function = *Buffer_CCP_CHAR
	End if
	
	' Liberer la memoire
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Buffer_CCP_CHAR)
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(MODE_CHAR)
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Chemin_CHAR)
End Function

Function __Noyau_Cpcdos_OSx__.Fichier_Existe(ByVal Chemin as String) as boolean
	' Cette fonction permet de verifier l'existence d'un fichier
	'	Chemin	: Chemin d'acces au fichier
	' Retourne 	TRUE presents
	'			FALSE pas present

	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	Chemin = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Chemin, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)

	

	if FileExists( Chemin ) <> 0 then function = true else function = false
	
	' exit function
	
	' Transformer en CHAR*
	' Dim Chemin_CHAR as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Chemin)
	
	' Recuperer la  taille du fichier
	' Function = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Fichier_Existe(Chemin_CHAR)
	
	' Liberer la memoire
	' CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Chemin_CHAR)
	
	
	
End Function

Function __Noyau_Cpcdos_OSx__.Taille_Fichier(ByVal Chemin as String) as uinteger
	' Cette fonction permet de recuperer la taille d'un fichier
	'	Chemin	: Chemin d'acces au fichier
	' Retourne la taille du fichier en unsigned int

	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	Chemin = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Chemin, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	
	Function = FileLen( Chemin )
	
	exit function
	
	' Transformer en CHAR*
	Dim Chemin_CHAR as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Chemin)
	
	
	' Recuperer la  taille du fichier
	Dim Taille_Du_Fichier as uinteger = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Taille_Fichier(Chemin_CHAR)
	
	
	IF Taille_Du_Fichier < 0 then
		' ' Sachant que le fichier est dabord teste, il s'agirait donc
		' ' d'une erreur interne de CPinti mais il concerne ce fichier
		Dim Message_erreur as String = ERRAVT("ERR_015", 0)
		DEBUG("[CpcdosC+] (CPinti core) : Erreur d'acces interne. " & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, "")
	End if
	
	' Liberer la memoire
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Chemin_CHAR)
	
	' Renvoyer le resultat
	Function = Taille_Du_Fichier
End Function

Function __Noyau_Cpcdos_OSx__.Ecrire_fichier_complet(ByVal Chemin as String, ByVal Donnees as String, ByVal FLAG as integer) as double
	' Cette fonction permet de lire un fichier complet
	'	Chemin	: Chemin d'acces au fichier
	' Retourne le contenu du fichier

	' Dim f As Integer = FreeFile
	
	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	Chemin = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Chemin, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	
	' Open Chemin For Binary As #f
	
	' put #f, , Donnees
	
	' close #f
	
	' Ecrire_fichier_complet = len(Donnees)
	
	' Transformer en CHAR*
	Dim Chemin_CHAR as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Chemin)
	
	' Transformer en CHAR* 
	DIM Donnees_CHAR as CONST ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Donnees)
	
	' Lire le fichier depuis CPinti Core
	Dim Resultat as double = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Ecrire_Fichier_complet(Chemin_CHAR, Donnees_CHAR, FLAG)
	
	IF Resultat < 0 then
		' Erreur d'ecriture
		Dim Message_erreur as String = ERRAVT("ERR_015", 0)
		DEBUG("[CpcdosC+] (CPinti core) : Erreur d'acces interne. " & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, "")
		
		Ecrire_fichier_complet = -1
	else
	
		' Renvoyer le nobre d'octets ecrits
		Ecrire_fichier_complet = Resultat
	End if
	
	' Liberer la memoire
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Donnees_CHAR)
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Chemin_CHAR)
End Function

Function __Noyau_Cpcdos_OSx__.Supprimer_Fichier(ByVal Chemin as String, ByVal securise as boolean, ByVal NombrePasses as integer) as boolean
	' Cette fonction permet de supprier un fichier du disque
	'	Chemin	: Chemin d'acces au fichier
	'	securise: Effacement securise
	'	NmPasses: Nombre de passes d'effacement
	
	' Retourne 	TRUE OK
	'			FALSE pas OK

	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	Chemin = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Chemin, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	
	' Transformer en CHAR*
	Dim Chemin_CHAR as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Chemin)
	
	
	' Supprimer le fichier depuis CPinti Core
	Supprimer_Fichier = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Supprimer_Fichier(Chemin_CHAR, securise, NombrePasses)
	
	' Liberer la memoire
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Chemin_CHAR)
End Function

Function __Noyau_Cpcdos_OSx__.Copier_Fichier(ByVal Source as String, ByVal Destination as String, ByVal Priorite as integer, ByVal Var_Progression as String, ByVal Var_Octets as String, ByVal Var_OctetsParSec as String) as boolean
	' Cette fonction permet de copier un fichier source a une destination
	
	'	Source	: Chemin d'acces au fichier source
	'	securise: Chemin d'acces au fichier destination
	' Priorite	= 0	: Copie par defaut a priorite automatisee (selon la charge du CPU)
	' 			= 1	: Copie normale (50%)
	' 			= 2	: Copie prioritaire, priorise plus le thread actuel (70%)
	'			= 3 : Copie a section critique (Bloque tous les autre threads et priorise a 100%)
	
	' VAR_Progression	: Variable destination pour la progression en %
	' VAR_Octets		: Variable destination pour la progression en octets
	' VAR_OctetsParSec	: Variable destination pour le nombre d'octets par secondes

	' Retourne 	TRUE OK
	'			FALSE pas OK
	
	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Source, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	Destination = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Destination, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)

	
	' Transformer en CHAR*
	Dim Source_CHAR 			as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Source)
	
	Dim Destination_CHAR 		as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(Destination)
	
	Dim VAR_Progression_CHAR 	as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(VAR_Progression)
	Dim VAR_Octets_CHAR 		as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(VAR_Octets)
	Dim VAR_OctetsParSec_CHAR 	as ZString PTR = CPCDOS_INSTANCE.SYSTEME_INSTANCE.AllouerString(VAR_OctetsParSec)
	
	
	
	' Copier le fichier depuis CPinti Core
	Copier_Fichier = CPCDOS_INSTANCE.CPintiCore_INSTANCE.cpinti_Copier_Fichier(Source_CHAR, Destination_CHAR, Priorite, VAR_Progression_CHAR, VAR_Octets_CHAR, VAR_OctetsParSec_CHAR)
	
	' Liberer la memoire
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(VAR_OctetsParSec_CHAR)
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(VAR_Octets_CHAR)
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(VAR_Progression_CHAR)
	
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Destination_CHAR)
	CPCDOS_INSTANCE.SYSTEME_INSTANCE.DesAllouerString(Source_CHAR)
End Function

Function __Noyau_Cpcdos_OSx__.Renommer_Fichier(ByVal Source as String, ByVal Destination as String) as boolean
	' Cette fonction permet de renommer un fichier source a une destination
	
	'	Source	: Chemin d'acces au fichier source
	'	securise: Chemin d'acces au fichier destination
	' Priorite	= 0	: Copie par defaut a priorite automatisee (selon la charge du CPU)
	' 			= 1	: Copie normale (50%)
	' 			= 2	: Copie prioritaire, priorise plus le thread actuel (70%)
	'			= 3 : Copie a section critique (Bloque tous les autre threads et priorise a 100%)
	
	' VAR_Progression	: Variable destination pour la progression en %
	' VAR_Octets		: Variable destination pour la progression en octets
	' VAR_OctetsParSec	: Variable destination pour le nombre d'octets par secondes

	' Retourne 	TRUE OK
	'			FALSE pas OK
	
	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Source, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	Destination = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Destination, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	

	Destination = Mid(Source, 1, InstrREV(Source, "\")) & Destination
	
	
	' UTILISATION TEMPORAIRE DU CRT0 DE FREEBASIC !! Independance en cours ;)
	Dim Resultat as integer = NAME(Source, Destination)
	
	' Compatibilite avec DOS
	if Resultat = 0 Then Resultat = 1
	Renommer_Fichier = Resultat
End Function

Function __Noyau_Cpcdos_OSx__.Deplacer_Fichier(ByVal Source as String, ByVal Destination as String) as boolean
	' Cette fonction permet de deplacer un fichier source a une destination
	
	'	Source	: Chemin d'acces au fichier source
	'	securise: Chemin d'acces au fichier destination
	' Priorite	= 0	: Copie par defaut a priorite automatisee (selon la charge du CPU)
	' 			= 1	: Copie normale (50%)
	' 			= 2	: Copie prioritaire, priorise plus le thread actuel (70%)
	'			= 3 : Copie a section critique (Bloque tous les autre threads et priorise a 100%)
	
	' VAR_Progression	: Variable destination pour la progression en %
	' VAR_Octets		: Variable destination pour la progression en octets
	' VAR_OctetsParSec	: Variable destination pour le nombre d'octets par secondes

	' Retourne 	TRUE OK
	'			FALSE pas OK
	
	' Filtrer les TAB, espaces et Retour chariot CR & LF 
	' Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Source, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	' Destination = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Destination, CHR(09)), CR), LF)), CHR(09))), TRUE, TRUE, FALSE)
	
	' Destination = Mid(Source, 1, InstrREV(Source, "\")) & Destination
	
	
	' ' UTILISATION TEMPORAIRE DU CRT0 DE FREEBASIC !! Independance en cours ;)
	' Dim Resultat as integer = NAME(Source, Destination)
	
	' ' Compatibilite avec DOS
	' if Resultat = 0 Then Resultat = 1
	' Renommer_Fichier = Resultat
	
	Deplacer_Fichier = false
End Function


#print * Heure
Function __Noyau_Cpcdos_OSx__.get_Heure(ByVal format_ as string) as string
	' Obtenir l'heure actuel dans un formatage personnalisee!
	' Format exemple avec 14 heure 50 minutes et 42 secondes
	' 	HH:MM:SS ( 14:50:42 )
	' 	HHhMM    ( 14h50    )
	' 	HH-MM:SS ( 14-50:42 )
	' 	SS.HH.MM ( 42.14.50 )
	'   etc...
	
	
	Dim Calc_ 		as integer
	' Trier l'heure du systeme synchronise
	Dim gTime		(0 to 2) as integer
	
	' index 0:Heure 1:Minutes 2:Secondes
	Dim _PRESENT	(0 to 2) as integer
	
	' Tout en majuscule
	format_ = UCASE(format_)

	
	Dim Resultat 	as string
	
	' Declarer les tableaux
	Dim Empl_TEMPS	(0 to 3) as String
	Dim final_TEMPS	(0 to 3) as String
	Dim Empl_SEP	(0 to 1) as String
	
	

	' Recuperer le RANG 1
	Empl_TEMPS	(0) = MID(format_, 1, 2) ' Recuperer le 1er rang
	Empl_SEP	(0) = MID(format_, 3, 1) ' Recuperer le 1er separateur
	
	
	' Recuperer le RANG 2
	Empl_TEMPS	(1) = MID(format_, 4, 2) ' Recuperer le 2eme rang
	Empl_SEP	(1) = MID(format_, 6, 1) ' Recuperer le 1er separateur
	
	' Recuperer le RANG 3
	Empl_TEMPS	(2) = MID(format_, 7, 2) ' Recuperer le 3er rang
	
	' Chercher la presence de HH
	For b as integer = 0 to 2
		IF Empl_TEMPS(b) = this.TYPES_INSTANCE._RTC_Heure Then 
			gTime(b) = this.SYSTEME_INSTANCE.get_Heures()
			_PRESENT(0) = 1
			exit for ' Optimisation
		End if
	Next b
	
	' Chercher la presence de MM
	For b as integer = 0 to 2
		IF Empl_TEMPS(b) = this.TYPES_INSTANCE._RTC_Minutes Then 
			gTime(b) = this.SYSTEME_INSTANCE.get_Minutes()
			_PRESENT(1) = 1
			exit for ' Optimisation
		End if
	Next b
	
	' Chercher la presence de SS
	For b as integer = 0 to 2
		IF Empl_TEMPS(b) = this.TYPES_INSTANCE._RTC_Secondes Then 
			gTime(b) = this.SYSTEME_INSTANCE.get_Secondes()
			_PRESENT(2) = 1
			exit for ' Optimisation
		End if
	Next b	
	
	' Calculer le nombre de rangs presents
	Calc_ = _PRESENT(0) + _PRESENT(1) + _PRESENT(2)	
	
	if Calc_ = 3 Then ' Les 3 rangs sont presents
		Resultat = gTime(0) & Empl_SEP(0) & gTime(1) & Empl_SEP(1) & gTime(2)
	ElseIF Calc_ = 2 Then ' 2 Rangs seulement
		Resultat = gTime(0) & Empl_SEP(0) & gTime(1)
	ElseIF Calc_ = 1 Then ' 1 Rang seulement
		Resultat = gTime(0) & ""
	Else
		Resultat = "<FORMAT ERR>" ' Erreur de format
	End if
	
	' Retourner le resultat
	get_Heure = Resultat
End Function

#print * Date
Function __Noyau_Cpcdos_OSx__.get_Date(ByVal format_ as string) as string
	' Obtenir la date actuel dans un formatage personnalisee!
	' Format exemple avec 14 heure 50 minutes et 42 secondes
	' 	HH:MM:SS ( 14:50:42 )
	' 	HHhMM    ( 14h50    )
	' 	HH-MM:SS ( 14-50:42 )
	' 	SS.HH.MM ( 42.14.50 )
	'   etc...
	
	
	Dim Addit 		as integer
	Dim Calc_ 		as integer
	
	' Trier l'heure du systeme synchronise
	Dim gDate		(0 to 2) 	as integer
	
	' index 0:Heure 1:Minutes 2:Secondes
	Dim _PRESENT	(0 to 2) 	as integer
	
	Dim Resultat 	as string
	
	' Declarer les tableaux
	Dim Empl_DATE	(0 to 3) 	as String
	Dim final_DATE	(0 to 3) 	as String
	Dim Empl_SEP	(0 to 1) 	as String
	
	

	' Tout en majuscule
	format_ = UCASE(format_)
	
	' Recuperer le RANG 1
	IF (MID(format_, 1, 4) = this.TYPES_INSTANCE._RTC_ANNEE(1)) OR (MID(format_, 1, 4) = this.TYPES_INSTANCE._RTC_ANNEE(3)) Then ' YYYY/AAAA ?
		Empl_DATE (0) = MID(format_, 1, 4)
		Addit = 2
	ELSE ' Autre chose!
		Empl_DATE (0) = MID(format_, 1, 2)
	END IF

	Empl_SEP	(0) = MID(format_, 3 + Addit, 1) ' Recuperer le 1er separateur
	
	
	' Recuperer le RANG 2
	Empl_DATE	(1) = MID(format_, 4 + Addit, 2) ' Recuperer le 2eme rang
	Empl_SEP	(1) = MID(format_, 6 + Addit, 1) ' Recuperer le 1er separateur
	
	' Recuperer le RANG 3
	IF (MID(format_, 7 + Addit, 4) = this.TYPES_INSTANCE._RTC_ANNEE(1)) OR (MID(format_, 7 + Addit, 4) = this.TYPES_INSTANCE._RTC_ANNEE(3)) Then ' YYYY ?
		Empl_DATE (2) = MID(format_, 7 + Addit, 4)
	ELSE ' Autre chose!
		Empl_DATE (2) = MID(format_, 7 + Addit, 2)
	END IF
	
	' Chercher la presence de DD ou JJ
	For b as integer = 0 to 2
		IF (Empl_DATE(b) = this.TYPES_INSTANCE._RTC_Jour(0)) OR (Empl_DATE(b) = this.TYPES_INSTANCE._RTC_Jour(1)) Then ' DD ou JJ
			gDate(b) = this.SYSTEME_INSTANCE.get_Jour()
			_PRESENT(0) = 1
			exit for ' Optimisation
		End if
	Next b
	
	' Chercher la presence de MM
	For b as integer = 0 to 2
		IF Empl_DATE(b) = this.TYPES_INSTANCE._RTC_MOIS Then 
			gDate(b) = this.SYSTEME_INSTANCE.get_Mois()
			_PRESENT(1) = 1
			exit for ' Optimisation
		End if
	Next b
	
	' Chercher la presence de YY / YYYY ou AA / AAAA
	For b as integer = 0 to 2
		IF (Empl_DATE(b) = this.TYPES_INSTANCE._RTC_ANNEE(0)) OR (Empl_DATE(b) = this.TYPES_INSTANCE._RTC_ANNEE(1))  OR (Empl_DATE(b) = this.TYPES_INSTANCE._RTC_ANNEE(2))  OR (Empl_DATE(b) = this.TYPES_INSTANCE._RTC_ANNEE(3)) Then
			if Len(Empl_DATE(b)) = 2 Then
				' YY
				gDate(b) = this.SYSTEME_INSTANCE.get_Annee() 
			ELSE
				' YYYY
				gDate(b) = val(this.SYSTEME_INSTANCE.get_Siecle() & this.SYSTEME_INSTANCE.get_Annee())
			End if
			_PRESENT(2) = 1
			exit for ' Optimisation
		End if
	Next b	
	
	' Calculer le nombre de rangs presents
	Calc_ = _PRESENT(0) + _PRESENT(1) + _PRESENT(2)	
	if Calc_ = 3 Then ' Les 3 rangs sont presents
		Resultat = gDate(0) & Empl_SEP(0) & gDate(1) & Empl_SEP(1) & gDate(2)
	ElseIF Calc_ = 2 Then ' 2 Rangs seulement
		Resultat = gDate(0) & Empl_SEP(0) & gDate(1)
	ElseIF Calc_ = 1 Then ' 1 Rang seulement
		Resultat = gDate(0) & ""
	Else
		Resultat = "<FORMAT ERR>" ' Erreur de format
	End if
	
	' Retourner le resultat
	get_Date = Resultat
End Function 


Function __Noyau_Cpcdos_OSx__.get_Date_format() as String
	' Cette fonction permet de retourner le format de date
	
	get_Date_format = get_Date_format(Generer_cle(get_id_kernel(), get_id_OS(), get_id_Utilisateur(), 0, 0))
End Function

Function __Noyau_Cpcdos_OSx__.get_Date_format(_CLE_ as Double) as String
	' Cette fonction permet de retourner le format de date
	
	get_Date_format = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_DATE.FORMAT", 4, _CLE_))
End Function

Function __Noyau_Cpcdos_OSx__.get_Time_format() as String
	' Cette fonction permet de retourner le format de l'heure
	
	get_Time_format = get_Time_format(Generer_cle(get_id_kernel(), get_id_OS(), get_id_Utilisateur(), 0, 0))
End Function

Function __Noyau_Cpcdos_OSx__.get_Time_format(_CLE_ as Double) as String
	' Cette fonction permet de retourner le format de l'heure
	
	get_Time_format = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_TIME.FORMAT", 4, _CLE_))
End Function

#print * Manipulation de chaines
Function __Noyau_Cpcdos_OSx__.remplacer_Caractere(ByVal Source as String, ByVal Caracteres as String, ByVal Remplacement as String) as String
	' Cette fonction permet de remplacer 1 ou une sequence de caracteres par celui definit
	
	' Pour eviter la boucle fatale ahah
	IF Source = "" OR Caracteres = Remplacement OR Caracteres = "" Then 
		remplacer_Caractere = "-1"
		Exit function
	End if
	
	IF INSTR(Source, Caracteres) > 0 Then

		Dim Taille_Source 		as integer = LEN(Source)
		Dim Taille_Caracteres	as integer = LEN(Caracteres)
		Dim POS_Caract 			as integer
		
		Dim DEBUT				as String
		Dim FIN					as String

		For Boucle as integer = 1 to Taille_Source
			POS_Caract = Instr(Source, Caracteres)
			
			IF POS_Caract > 0 Then
				DEBUT = MID(Source, 1, POS_Caract - 1)
				FIN = MID(Source, POS_Caract + Taille_Caracteres)
			Else
				Source = DEBUT & Remplacement & FIN
				exit for
			End if
			' Assemblage
			Source = DEBUT & Remplacement & FIN
		Next boucle
	End if
	

	remplacer_Caractere = Source
End Function

Function __Noyau_Cpcdos_OSx__.compter_Caractere(ByVal Source as String, ByVal Caracteres as String) as Integer
	' Cette fonction permet de compter le nombre de caractere souhaite
	
	' Pour eviter la boucle fatale ahah
	IF Source = "" OR Caracteres = "" Then 
		compter_Caractere = -1
		Exit function
	End if

	Dim Taille_Source 		as integer = LEN(Source)
	Dim Taille_Caracteres	as integer = LEN(Caracteres)
	Dim POS_Caract 			as integer
	Dim Comptage			as integer = 0
	
	Dim DEBUT				as String
	Dim FIN					as String

	For Boucle as integer = 1 to Taille_Source
		POS_Caract = Instr(Source, Caracteres)
		
		IF POS_Caract > 0 Then
			Comptage = Comptage + 1
			DEBUT = MID(Source, 1, POS_Caract - 1)
			FIN = MID(Source, POS_Caract + Taille_Caracteres)
		Else
			Source = DEBUT & FIN
			exit for
		End if
		' Assemblage
		Source = DEBUT & FIN
	Next boucle
	

	compter_Caractere = Comptage
End Function


#print * Gestionnaire des Systemes d exploitations
Sub __Noyau_Cpcdos_OSx__.update_OS_LISTE()
	' Cette fonction permet de mettre a jour la liste des OS
	'  present dans OS.LST
	
	Dim OS_LISTE as String = "OS/OS.LST"
	
	IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
		IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
			DEBUG("[Cpcdos] Mise a jours des informations des OS installes ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
		Else
			DEBUG("[Cpcdos] Updating informations about installed OS  ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
		End If
	End if
	
	
	Dim Position_Debut 	as integer = 1
	Dim Position_FIN 	as integer = 1
	Dim Position_2PTS 	as integer = 1

	' Lire le contenu depuis CPinti core
	Dim Buffer_Fichier 	as String = CPCDOS_INSTANCE.Lire_fichier_complet(OS_LISTE)
	
	Dim Chaine_Ligne 	as string
	
	For Boucle as integer = 0 to CPCDOS_INSTANCE._MAX_NOMBRE_OS
		
		Position_FIN = INSTR(Position_Debut, Buffer_Fichier, CRLF)
		
		if Position_FIN < 1 then Position_FIN = Len(Buffer_Fichier)
		
		' Recuperer la ligne dans le fichier en supprimant le CRLF a la fin
		Chaine_Ligne = Mid(Buffer_Fichier, Position_Debut, Position_FIN - Position_Debut)
		
		if Chaine_Ligne = "" Then Exit for
		
		Position_Debut = Position_FIN + 2
		
		' Recuperer le nom de l'OS
		CPCDOS_INSTANCE._LISTE__OS_NOM(Boucle) = RTRIM(RTRIM(RTRIM(MID(Chaine_Ligne, 1, Instr(Chaine_Ligne, ":") - 1), chr(13)), chr(10)))

		' Recuperer le chemin d'acces de l'OS
		CPCDOS_INSTANCE._LISTE__OS_PATH(Boucle) =  RTRIM(RTRIM(RTRIM(MID(Chaine_Ligne, Instr(Chaine_Ligne, ":") + 1), chr(13)), chr(10)))
		
		' Mettre a jour le nombre d'OS
		CPCDOS_INSTANCE._LISTE__OS_NB = Boucle + 1
		
		if Position_FIN = Len(Buffer_Fichier) Then exit for
	Next Boucle
	
	IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
		IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
			DEBUG("[Cpcdos] Mise a jour terminee.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
		Else
			DEBUG("[Cpcdos] Updating terminated.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
		End If
	End if
End Sub

Function __Noyau_Cpcdos_OSx__.get_NombreOSPresent() as integer
	' Cette fonction permet d'obtenir le nombre d'OS present dans le fichier
	'  OS.LST
	
	get_NombreOSPresent = CPCDOS_INSTANCE._LISTE__OS_NB
	
End function

Function __Noyau_Cpcdos_OSx__.get_OSPresent() as String
	' Cette fonction permet d'obtenir le nombre d'OS present dans le fichier
	'  OS.LST
	Dim Liste_Present as String = ""
	
	For Boucle as integer = 0 to CPCDOS_INSTANCE._MAX_NOMBRE_OS - 1
		if NOT CPCDOS_INSTANCE._LISTE__OS_NOM(Boucle) = "" Then
			Liste_Present = Liste_Present & Boucle & ":" & CPCDOS_INSTANCE._LISTE__OS_NOM(Boucle) & " PATH:OS/" & CPCDOS_INSTANCE._LISTE__OS_PATH(Boucle) & CRLF
		End if
	Next Boucle
	
	
	Function = Liste_Present
End function

Function __Noyau_Cpcdos_OSx__.get_OSPresent(_INDEX_ as integer) as String
	' Cette fonction permet de retourner le nom + path de l'OS via son index
	' Renvoit rien si ya rien aha
	
	Dim OS_Present as String = ""
	
	IF _INDEX_ = CPCDOS_INSTANCE._MAX_NOMBRE_OS Then OS_Present = "Without OS - Cpcdos blank kernel interface"
	
	if NOT CPCDOS_INSTANCE._LISTE__OS_NOM(_INDEX_) = "" Then 
		OS_Present = CPCDOS_INSTANCE._LISTE__OS_NOM(_INDEX_) & " PATH:OS/" & CPCDOS_INSTANCE._LISTE__OS_PATH(_INDEX_)
	End if
	
	Function = OS_Present
End function

Function __Noyau_Cpcdos_OSx__.test_OSPresent(ByVal Nom as String) as Integer
	' Cette fonction permet de retourner l'index d'un nom d'OS existant
	
	' Dernier de la liste
	if Nom = "#WITHOUT-SANSOS#" Then
		Function = CPCDOS_INSTANCE._MAX_NOMBRE_OS
		exit function
	End if
	
	' Enlever les espaces
	Nom = UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Nom, " ", ""))

	For Boucle as integer = 0 to CPCDOS_INSTANCE._MAX_NOMBRE_OS - 1
		if NOT CPCDOS_INSTANCE._LISTE__OS_NOM(Boucle) = "" Then 
			IF Ucase(CPCDOS_INSTANCE._LISTE__OS_NOM(Boucle)) = Nom Then
				' Renvoyer le numero d'INDEX
				Function = Boucle
				exit function
			End if
		End if
	Next Boucle

	Function = -1 ' OS non trouve
End function


Function __Noyau_Cpcdos_OSx__.Charger_Image(ByVal ImageSource as String) as Any PTR
	' Cette fonction permet de charger une image PNG, JPG, JTIF ou MJPEG
	' Renvoie le pointeur
	Dim Hauteur as integer
	Dim Largeur as integer

	Function = Charger_Image(ImageSource, Hauteur, Largeur)
	
End Function

Function __Noyau_Cpcdos_OSx__.Charger_Image(ByVal ImageSource as String, byref Hauteur as integer, byref Largeur as integer) as Any PTR
	' Cette fonction permet de charger une image PNG, JPG, JPEG, JFIF ou MJPG
	' Renvoie le pointeur et les dimensions X et Y

	ImageSource = Ucase(ImageSource)
	
	If Mid(ImageSource, Len(ImageSource) - 3) = ".PNG" Then
		' Charger une image PNG
		
		IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CPCDOS] Charge_Image() '" & ImageSource & "' --> Format PNG supporte!", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SYSTEME_INSTANCE.RetourVAR_PNG)
			Else
				DEBUG("[CPCDOS] Charge_Image() '" & ImageSource & "' --> Supported PNG format !", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SYSTEME_INSTANCE.RetourVAR_PNG)
			End if
		End if
		
		Function = CPCDOS_INSTANCE.SYSTEME_INSTANCE.Charger_PNG(ImageSource, CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_BitsparPixels(), 50, Hauteur, Largeur)
		
		Exit function
	ElseIF Mid(ImageSource, Len(ImageSource) - 3) = ".JPG" OR _
			Mid(ImageSource, Len(ImageSource) - 4) = ".JPEG" OR _
			Mid(ImageSource, Len(ImageSource) - 4) = ".JFIF" OR _
			Mid(ImageSource, Len(ImageSource) - 4) = ".MJPG" Then
		' Charger une image JPG, JPEG, JFIF ou MJPG
		
		IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CPCDOS] Charge_Image() '" & ImageSource & "' --> Format JPG supporte!", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SYSTEME_INSTANCE.RetourVAR_PNG)
			Else
				DEBUG("[CPCDOS] Charge_Image() '" & ImageSource & "' --> Supported JPG format !", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SYSTEME_INSTANCE.RetourVAR_PNG)
			End if
		End if
			
		Function = CPCDOS_INSTANCE.SYSTEME_INSTANCE.Charger_JPG(ImageSource, CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_BitsparPixels(), 50, Hauteur, Largeur)
		
		Exit function
	End if
	
	
	IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CPCDOS] Charge_Image() '" & ImageSource & "' --> Format non supporte!", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SYSTEME_INSTANCE.RetourVAR_PNG)
			Else
				DEBUG("[CPCDOS] Charge_Image() '" & ImageSource & "' --> No supported format !", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, CPCDOS_INSTANCE.SYSTEME_INSTANCE.RetourVAR_PNG)
			End if
		End if
	
	
	
End Function


public sub __Noyau_Cpcdos_OSx__.tester_erreur_memoire()
	SCOPE
		Dim testerreur as boolean = false
		for Boucle as integer = 1 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE._MAX_CMD_CCP
			if boucle > CPCDOS_INSTANCE.SHELLCCP_INSTANCE._MAX_CMD_CCP then exit for
		
			' DEV temporaire: Si commande vide alors on saute
			'  directement aux commandes graphiques
			IF CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_FR(boucle) = "" AND boucle < 128 Then boucle = 128
			
			' Chercher la syntaxe Francophone
			IF Instr(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_FR(Boucle), "/") > 0 OR Instr(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_FR(Boucle), ".") = 1 Then
			Else
				testerreur = true
				Print "FR ERREUR(" & boucle & "):" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_FR(Boucle) & "."
			End if
			
			' Chercher la syntaxe Anglophone
			IF Instr(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_EN(Boucle), "/") > 0 OR Instr(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_EN(Boucle), ".") = 1 Then
			Else
				testerreur = true
				Print "EN ERREUR(" & boucle & "):" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.Liste_CMD_EN(Boucle) & "."
			End if
			
		Next Boucle


		if testerreur = true Then 
			Print "Des erreurs detectes"
			Print "Appuyer sur une touche"
			sleep
		End if
	END SCOPE
end SUB


